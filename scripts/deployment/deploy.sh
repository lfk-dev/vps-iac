#!/usr/bin/env bash

# NOTE: script generated by AI, reviewed and understand line by line

# This script is responsible for running compose.yaml stored in different directories
# The current dir at the start is the github.workspace which after checkout is the root of the repo
#
# 1. Iterate over all directories in `docker/`
# 2. Run docker compose up for each directory
# 3. If there is a conf.d subdir, copy the contents to /etc/srv/configs/<project_name>/

echo "=========================================="
echo "./scripts/deployment/deploy.sh STARTED"
echo "=========================================="

set -euo pipefail

# Configuration - these should be passed as environment variables
: "${VPS_SSH_PORT:?Error: VPS_SSH_PORT is not set}"
: "${VPS_SSH_USER:?Error: VPS_SSH_USER is not set}"
: "${VPS_DOMAIN:?Error: VPS_DOMAIN is not set}"

DOCKER_DIR="./docker"

if [[ ! -d "$DOCKER_DIR" ]]; then
    echo "Error: docker directory not found at $DOCKER_DIR" >&2
    exit 1
fi

deploy_project() {
    local project_dir="$1"
    local project_name
    
    echo "=========================================="
    echo "Deploying: $(basename "$project_dir")"
    echo "=========================================="
    
    # Verify compose file exists
    if [[ ! -f "${project_dir}/compose.yaml" ]] && [[ ! -f "${project_dir}/compose.yml" ]]; then
        echo "Warning: No compose.yaml or compose.yml found in ${project_dir}, skipping" >&2
        return 0
    fi
    
    # Handle conf.d if it exists
    local conf_dir="${project_dir}/conf.d"
    if [[ -d "$conf_dir" ]]; then
        # Parse project name from compose config
        project_name=$(docker compose --project-directory "$project_dir" config --format json 2>/dev/null | jq -r '.name // empty')
        
        if [[ -z "$project_name" ]]; then
            echo "Warning: conf.d found but could not parse project name, skipping config copy" >&2
        elif [[ ! "$project_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            echo "Error: Invalid project name '$project_name' - contains unsafe characters" >&2
            return 1
        else
            echo "Copying config files to /etc/srv/configs/${project_name}/"
            
            # Create remote directory and copy files
            # shellcheck disable=SC2029
            # remove files first, to prevent failed copy
            # chown is recursive, although should not be needed (<project_name> should be empty)
            ssh -p "$VPS_SSH_PORT" "${VPS_SSH_USER}@${VPS_DOMAIN}" \
                "sudo rm -rf '/etc/srv/configs/${project_name}' && sudo mkdir -p '/etc/srv/configs/${project_name}' && sudo chown -R ${VPS_SSH_USER} '/etc/srv/configs/${project_name}'" || {
                echo "Error: Failed to create remote config directory" >&2
                return 1
            }
            
            scp -r -P "$VPS_SSH_PORT" "${conf_dir}/." \
                "${VPS_SSH_USER}@${VPS_DOMAIN}:/etc/srv/configs/${project_name}/" || {
                echo "Error: Failed to copy config files" >&2
                return 1
            }
        fi
    fi
    
    # Run docker compose AFTER the config is copied (so the bind mount works) TODO: clean up the files from the VPS if the deployment fails
    if ! docker compose --project-directory "$project_dir" --env-file "${DOCKER_DIR}/.env" up -d; then
        echo "Error: docker compose failed for $(basename "$project_dir")" >&2
        return 1
    fi

    echo "Successfully deployed $(basename "$project_dir")"
    return 0
}

main() {
    local failed=0
    
    # Verify .env file exists
    if [[ ! -f "${DOCKER_DIR}/.env" ]]; then
        echo "Error: .env file not found at ${DOCKER_DIR}/.env" >&2
        exit 1
    fi
    
    # Iterate over directories only (not files, not hidden)
    for dir in "${DOCKER_DIR}"/*/; do
        # Skip if glob didn't match anything
        [[ -d "$dir" ]] || continue
        
        if ! deploy_project "$dir"; then
            echo "Error deploying $(basename "$dir")" >&2
            ((failed++))
        fi
    done
    
    if ((failed > 0)); then
        echo "=========================================="
        echo "Deployment completed with $failed failure(s)"
        echo "=========================================="
        exit 1
    fi
    
    echo "=========================================="
    echo "All deployments completed successfully"
    echo "=========================================="
}

main "$@"